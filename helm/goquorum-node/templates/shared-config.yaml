# kubectl create configmap game-config --from-file=configure-pod-container/dd1/key
apiVersion: v1
kind: ConfigMap
metadata:
  name: quorum-permissioned
  
  labels:
    app: quorum
    name: quorum-permissioned
data:
  permissioned-nodes.json: |

    [
        {{ $scope := . }}
        {{- $first := true -}}
        {{- range $k, $v := .Values.eNodes -}}
            {{- if $first -}}
              {{- $first = false -}}
            {{- else -}}
              ,

            {{- end -}}
        "enode://{{ $v.enode }}@{{ $v.gethUrl }}:{{ $scope.Values.node.quorum.p2p.port }}?discport=0"
        {{- end -}}
        
    ]

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: contracts
  
  labels:
    app: quorum
    name: contracts
data:
  runscript.sh: |-
    #!/bin/ash
    PRIVATE_CONFIG=$TM_HOME/tm.ipc geth --exec "loadScript(\"$1\")" attach --datadir $QUORUM_DATA_DIR ipc:$QUORUM_DATA_DIR/geth.ipc
# set the tm.pub for node1 in the privateFor field.
# supports single node deployment.
  private_contract.js: |-

    a = eth.accounts[0]
    web3.eth.defaultAccount = a;
    
    // abi and bytecode generated from simplestorage.sol:
    // > solcjs --bin --abi simplestorage.sol
    var abi = [{"constant":true,"inputs":[],"name":"storedData","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"x","type":"uint256"}],"name":"set","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"},{"inputs":[{"name":"initVal","type":"uint256"}],"payable":false,"type":"constructor"}];
    
    var bytecode = "0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029";
    
    var simpleContract = web3.eth.contract(abi);
    var simple = simpleContract.new(42, {from:web3.eth.accounts[0], data: bytecode, gas: 0x47b760, privateFor: ["jOag/7g9l6L9sdBGL3VARRAJHAiOp0moVlSY15Pa4H0="]}, function(e, contract) {
    	if (e) {
    		console.log("err creating contract", e);
    	} else {
    		if (!contract.address) {
    			console.log("Contract transaction send: TransactionHash: " + contract.transactionHash + " waiting to be mined...");
    		} else {
    			console.log("Contract mined! Address: " + contract.address);
    			console.log(contract);
    		}
    	}
    });
  public_contract.js: |-
    a = eth.accounts[0]
    web3.eth.defaultAccount = a;
    
    // abi and bytecode generated from simplestorage.sol:
    // > solcjs --bin --abi simplestorage.sol
    var abi = [{"constant":true,"inputs":[],"name":"storedData","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"x","type":"uint256"}],"name":"set","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"get","outputs":[{"name":"retVal","type":"uint256"}],"payable":false,"type":"function"},{"inputs":[{"name":"initVal","type":"uint256"}],"payable":false,"type":"constructor"}];
    
    var bytecode = "0x6060604052341561000f57600080fd5b604051602080610149833981016040528080519060200190919050505b806000819055505b505b610104806100456000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632a1afcd914605157806360fe47b11460775780636d4ce63c146097575b600080fd5b3415605b57600080fd5b606160bd565b6040518082815260200191505060405180910390f35b3415608157600080fd5b6095600480803590602001909190505060c3565b005b341560a157600080fd5b60a760ce565b6040518082815260200191505060405180910390f35b60005481565b806000819055505b50565b6000805490505b905600a165627a7a72305820d5851baab720bba574474de3d09dbeaabc674a15f4dd93b974908476542c23f00029";
    
    var simpleContract = web3.eth.contract(abi);
    var simple = simpleContract.new(42, {from:web3.eth.accounts[0], data: bytecode, gas: 0x47b760}, function(e, contract) {
            if (e) {
                    console.log("err creating contract", e);
            } else {
                    if (!contract.address) {
                            console.log("Contract transaction send: TransactionHash: " + contract.transactionHash + " waiting to be mined...");
                    } else {
                            console.log("Contract mined! Address: " + contract.address);
                            console.log(contract);
                    }
            }
    });



## Addition config used to manage the nodes lifecycle, e.g. add /remove nodes.
## include ibft helpers as we don't know which nodes will be running which consensus.

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: node-management
  
  labels:
    app: quorum
    name: node-management
data:
  ibft_propose.sh: |-
    #/bin/ash
    
    if [ $# -lt 1 ]; then
      echo " An address to vote in, or out, must be provided: "
      echo " ./propose_ibft.sh HEX_ADDRESS (true|false)"
    fi
    
    ADDRESS=$1
    VOTE_BOOL=true
    
    if [ $# -eq 2 ]; then
     VOTE_BOOL=$2
    fi
    RES=$(geth --exec "istanbul.propose(\"$1\", $VOTE_BOOL)" attach ipc:$QUORUM_HOME/dd/geth.ipc)
    echo $RES
  ibft_propose_all.sh: |-
    #!/bin/ash
    #set -xe
    
    for Addr in $( awk '/validators/,0' $QHOME/istanbul-validator-config.toml/istanbul-validator-config.toml | grep "0x" | sed 's/,//g; s/"//g' ); do
      echo $Addr
      $QHOME/node-management/ibft_propose.sh $Addr true
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: istanbul-validator-config.toml
  
  labels:
    app: quorum
    name: istanbul-validator-config
data:
  istanbul-validator-config.toml: |
    vanity = "0x00"
    validators = [

        {{ $scope := . }}
        {{- $first := true -}}
        {{- range $k, $v := .Values.eNodes -}}
            {{- if $first -}}
              {{- $first = false -}}
            {{- else -}}
              ,
            {{- end -}}
          "{{ $v.nodekeyAddress }}"
        {{- end -}}

    ]

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: geth-helpers
  
  labels:
    app: quorum
    name: geth-helpers
data:
  geth-attach.sh: |-
    #!/bin/sh
    
    # helper for connecting to geth from
    # outside the container
    # kubectl exec -it $POD -c quorum -- /geth-helpers/geth-attach.sh
    echo "connecting to geth $QHOME"
    geth attach --datadir $QUORUM_DATA_DIR $QUORUM_DATA_DIR/geth.ipc
  geth-exec.sh: |-
    #!/bin/sh
    
    # helper for connecting to geth from
    # outside the container
    # kubectl exec -it $POD -c quorum -- /geth-helpers/geth-exec.sh "admin.peers.length"
    
    GETH_CMD="eth.blockNumber"
    if [ "$#" -gt 0 ]; then
      GETH_CMD=$1
    fi
    # see: https://github.com/ethereum/go-ethereum/pull/17281
    # https://github.com/ethereum/go-ethereum/issues/16905
    # to avoid warning being returned
    # "WARN [02-20|00:21:04.382] Sanitizing cache to Go's GC limits  provided=1024 updated=663"
    geth --exec $GETH_CMD  --cache=16 attach --datadir $QUORUM_DATA_DIR $QUORUM_DATA_DIR/geth.ipc
{{- if or .Values.node.quorum.qmKeyhashicorpVault.enabled .Values.node.quorum.securityPlugin.enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: quorum-plugin
  labels:
    app: quorum
    name: quorum-plugin
data:
  plugin.json: |-
    {
        "providers": {
            {{- if .Values.node.quorum.qmKeyhashicorpVault.enabled }}
            "account": {
                "name": "quorum-account-plugin-hashicorp-vault",
                "version": "0.1.0",
                "config": "file://{{ .Values.global.pluginPath }}/vault-plugin.json"
            }{{- end -}}{{- if and .Values.node.quorum.qmKeyhashicorpVault.enabled .Values.node.quorum.securityPlugin.enabled }},{{- end -}}
            {{- if .Values.node.quorum.securityPlugin.enabled }}
            "security": {
                "name": "quorum-security-plugin-enterprise",
                "version": "0.1.2",
                "config": "file://{{ .Values.global.pluginPath }}/security-plugin.json"
            }
            {{- end }}
        }
    }
{{- end }}
{{- if .Values.node.quorum.qmKeyhashicorpVault.enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: quorum-vault
  labels:
    app: quorum
    name: quorum-vault
data:
  vault-plugin.json: |-
    {
        "vault": "{{ .Values.node.quorum.qmKeyhashicorpVault.url }}",
        "kvEngineName": "{{ .Values.node.quorum.qmKeyhashicorpVault.secretEngineName }}",
        "accountDirectory": "file://{{ .Values.global.vaultPath }}/keystore",
        "unlock": ["{{ .Values.node.quorum.qmKeyhashicorpVault.accountAddress }}"],
        "authentication": {   
            "roleId": "env://HASHICORP_ROLE_ID",
            "secretId": "env://HASHICORP_SECRET_ID",
            "approlePath": "approle"
        }
    }
  accounts.txt: |-
    {"Address":"{{ .Values.node.quorum.qmKeyhashicorpVault.accountAddress }}","VaultAccount":{"SecretName":"{{ .Values.node.quorum.qmKeyhashicorpVault.secretName }}","SecretVersion":{{ .Values.node.quorum.qmKeyhashicorpVault.secretVersion }}},"Version":1}
{{- end }}
{{- if eq .Values.node.quorum.securityPlugin.enabled true }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: quorum-security
  labels:
    app: quorum
    name: quorum-security
data:
  security-plugin.json: |-
    {
        "tls": {
            "auto": false,
            "certFile": "env://TLS_CERT_FILE",
            "keyFile": "env://TLS_KEY_FILE"
        }
    }
---
apiVersion: v1
kind: Secret
metadata:
  name: quorum-tls
data:
  cert.pem: |-
    {{ .Values.node.quorum.securityPlugin.cert | b64enc }}
  key.pem: |-
    {{ .Values.node.quorum.securityPlugin.key | b64enc }}
{{- end }}